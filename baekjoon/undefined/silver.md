---
description: ê·¸ë˜í”„ íƒìƒ‰ Silver ë‹¨ê³„ ë¬¸ì œ í’€ì´ ëª¨ìŒ
---

# ğŸ¥ˆ Silver

## 4963 ì„¬ì˜ ê°œìˆ˜

[ë¬¸ì œë¡œ ì´ë™](https://www.acmicpc.net/problem/4963)

#### ë¬¸ì œ ìš”ì•½

ì„¬ì´ ëª‡ ê°œì¸ì§€ ì°¾ëŠ” ë¬¸ì œì´ë‹¤. ì¦‰, ì£¼ì–´ì§„ ì¸ì ‘í–‰ë ¬ì—ì„œ ê·¸ë˜í”„ê°€ ëª‡ ê°œ ìˆëŠ”ì§€ í™•ì¸í•´ì•¼í•œë‹¤. (ì—°ê²°ëœ ì»´í¬ë„ŒíŠ¸ê°€ ëª‡ê°œì•¼?)

íŠ¹ì´í•œ ê±´ ëŒ€ê°ì„ ê¹Œì§€ ì—°ê²°ëœ ì»´í¬ë„ŒíŠ¸ë¡œ ì •ì˜í•œë‹¤ëŠ” ê²ƒì´ë‹¤



#### ì•Œê³ ë¦¬ì¦˜

1. ì…ë ¥ìœ¼ë¡œ "0 0"ì´ ë“¤ì–´ì˜¬ ë•Œê¹Œì§€ ë°˜ë³µí•œë‹¤.
2. map (ì§€ë„)ë¥¼ ì…ë ¥ë°›ëŠ”ë‹¤.
3. w, h í¬ê¸°ì— ë§ì¶° visitedë¥¼ ì´ˆê¸°í™”í•œë‹¤.
4. mapì„ ìˆœíšŒí•˜ë©°, ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì•˜ê³ , ì„¬ì´ë¼ë©´ BFSë¥¼ ì‹¤í–‰í•œë‹¤.
5. BFSë¥¼ ëª‡ ë²ˆ ìˆœíšŒí–ˆëŠ”ì§€ ì¶œë ¥í•œë‹¤.

#### ì ‘ê·¼ ë°©ë²•

* BFSì— map, visitedë¥¼ ë§¤ê°œë³€ìˆ˜ë¡œ ê³„ì† ë„£ê³ ì‹¶ì§€ ì•Šë‹¤ë©´, ì „ì—­ìœ¼ë¡œ ì„ ì–¸í•˜ì!
* í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ê°€ ì§€ì •ë˜ì§€ ì•Šì•˜ë‹¤ë©´, whileë¬¸ì„ í†µí•´ ì…ë ¥ë°›ì•„ì•¼í•œë‹¤.

#### ì½”ë“œ

<pre class="language-swift"><code class="lang-swift"><strong>// ì´ë™ ë°©í–¥ ì •ì˜
</strong><strong>let dy = [1, 1, 1, 0, 0, -1, -1, -1]
</strong>let dx = [-1, 0, 1, -1, 1, -1, 0, 1]

var map = [[Int]]()
var visited = [[Bool]]()

// ì£¼ì–´ì§„ ë°ì´í„° ì…ë ¥ ë°›ê¸°
while let input = readLine() {
    if input == "0 0" { break }
    let input = input.split { $0 == " " }.map { Int($0)! }, (w, h) = (input[0], input[1])
    var count = 0
    map = []
    
    for _ in 0 ..&#x3C; h {
        map.append(readLine()!.split { $0 == " " }.map { Int($0)! })
    }
    visited = [[Bool]](repeating: [Bool](repeating: false, count: w), count: h)
    
    for y in 0 ..&#x3C; h {
        for x in 0 ..&#x3C; w {
            if map[y][x] == 1 &#x26;&#x26; !visited[y][x] {
                count += 1
                bfs(y, x, h, w)
            }
        }
    }
    print(count)
}

// bfs
func bfs(_ y: Int, _ x: Int, _ h: Int, _ w: Int ) {
    
    var queue = [(y, x)]
    visited[y][x] = true
    
    while !queue.isEmpty {
        let (y, x) = queue.removeFirst()
        
        for i in 0 ..&#x3C; 8 {
            let ny = dy[i] + y
            let nx = dx[i] + x

            guard 0..&#x3C;h ~= ny &#x26;&#x26; 0..&#x3C;w ~= nx &#x26;&#x26; map[ny][nx] == 1 &#x26;&#x26; !visited[ny][nx] else { continue }
            visited[ny][nx] = true
            queue.append((ny, nx))
        }
    }
}
</code></pre>



## 7562 ë‚˜ì´íŠ¸ì˜ ì´ë™

[ë¬¸ì œë¡œ ì´ë™](https://www.acmicpc.net/problem/7562)

#### ë¬¸ì œ ìš”ì•½

ì²´ìŠ¤ íŒ ìœ„ì— ë‚˜ì´íŠ¸ë¥¼ ì´ë™ì‹œí‚¤ë©´ì„œ íŠ¹ì • (y, x)ì— ë„ë‹¬í•˜ê¸° ìœ„í•´ ëª‡ ë²ˆ ì›€ì§ì—¬ì•¼í•˜ëŠ”ì§€ ê³„ì‚°í•´ì•¼í•œë‹¤. ì¦‰, (y, x)ì— ë„ë‹¬í•˜ê¸° ìœ„í•œ ìµœë‹¨ê±°ë¦¬ê°€ ì–¼ë§ˆì¸ì§€ êµ¬í•˜ëŠ” ë¬¸ì œë¼ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤.

#### ì•Œê³ ë¦¬ì¦˜

1. test caseë§Œí¼ ë°˜ë³µí•œë‹¤.
2. ì²´ìŠ¤ íŒì˜ í¬ê¸°, ì‹œì‘ ìœ„ì¹˜, ëª©í‘œ ìœ„ì¹˜ë¥¼ ì…ë ¥ë°›ëŠ”ë‹¤.
3. ì²´ìŠ¤ íŒì˜ í¬ê¸°ë§Œí¼ visited ë°°ì—´ì„ ì„ ì–¸í•œë‹¤.
4. BFSë¥¼ ìˆ˜í–‰í•´ì„œ ìµœë‹¨ê±°ë¦¬ë¥¼ ê³„ì‚°í•œë‹¤.

#### ì ‘ê·¼ë°©ë²•

* ë‚˜ì´íŠ¸ì˜ ì´ë™ë°©í–¥ì„ ì˜ ê³„ì‚°í•´ì•¼í•œë‹¤. (ì¢Œí‘œë¥¼ ê·¸ë ¤ì„œ ìƒê°í•´ë³´ì)
* ìµœë‹¨ê±°ë¦¬ì´ê¸° ë•Œë¬¸ì— visited ë°°ì—´ì„ Intë¡œ ì„ ì–¸í•˜ê³ , ì›€ì§ì¼ ë•Œë§ˆë‹¤ +1ì„ í•´ì„œ depthë¥¼ êµ¬í•˜ì.
*   ëª©í‘œ ì§€ì ì— ë‹¿ì•˜ë‹¤ë©´, visited\[goalY]\[goal\[X] - 1ì„ ì¶œë ¥í•´ì•¼í•œë‹¤.

    ì²« ìœ„ì¹˜ëŠ” ì›€ì§ì´ì§€ ì•Šê³  ë„ë‹¬í•˜ê¸° ë•Œë¬¸ì— depthëŠ” 0ì¸ë°, í¸ì˜ìƒ visitedì— 1ë¡œ ë°©ë¬¸ì²˜ë¦¬ í–ˆê¸° ë•Œë¬¸ì´ë‹¤.

    ì´ê²ƒì´ í—·ê°ˆë¦°ë‹¤ë©´ visitedë¥¼ -1ë¡œ ì´ˆê¸°í™”í•´ë„ ëœë‹¤! ë˜ëŠ” visited\[y]\[x]ë¡œ ë°”ë¡œ ì¶œë ¥í•´ë²„ë¦¬ì!
* ë§Œì•½ ì‹œì‘ ìœ„ì¹˜ê°€ ëª©í‘œì§€ì ì´ë¼ë©´ 0ì„ ì¶œë ¥í•´ì•¼í•œë‹¤.

#### ì½”ë“œ

```swift
// ë‚˜ì´íŠ¸ê°€ ì´ë™í•  ìˆ˜ ìˆëŠ” ë°©í–¥
let dy = [2, 2, 1, 1, -1, -1, -2, -2]
let dx = [-1, 1, -2, 2, -2, 2, -1, 1]

// ì •ë³´ë¥¼ ì…ë ¥ë°›ê³ , testcaseë§Œí¼ bfsë¥¼ ìˆ˜í–‰í•œë‹¤.
var visited = [[Int]]()
let testCase = Int(readLine()!)!
for _ in 0 ..< testCase {
    let l = Int(readLine()!)!
    let input = readLine()!.split { $0 == " " }.map { Int($0)! }, (x, y) = (input[0], input[1])
    let input2 = readLine()!.split { $0 == " " }.map { Int($0)! }, (goalX, goalY) = (input2[0], input2[1])
    visited = [[Int]](repeating: [Int](repeating: 0, count: l), count: l)
    print(bfs(y, x, goalY, goalX, l))
}

func bfs(_ y: Int, _ x: Int, _ goalY: Int, _ goalX: Int, _ l: Int) -> Int {

    // ì‹œì‘ìœ„ì¹˜ì™€ ëª©í‘œìœ„ì¹˜ê°€ ê°™ë‹¤ë©´ 0ì„ ë¦¬í„´í•œë‹¤. 
    guard (y, x) != (goalY, goalX) else { return 0 }
    var queue = [(y, x)]
    visited[y][x] = 1
    
    while !queue.isEmpty {
        let (y, x) = queue.removeFirst()
        for i in 0 ..< dy.count {
            let ny = dy[i] + y
            let nx = dx[i] + x
                        
            guard 0..<l ~= ny && 0..<l ~= nx && visited[ny][nx] == 0 else { continue }
            visited[ny][nx] = visited[y][x] + 1
            
            // ëª©í‘œì§€ì ì— ë„ë‹¬í–ˆë‹¤ë©´, depthë¥¼ ë¦¬í„´í•œë‹¤.
            if ny == goalY && nx == goalX { return visited[y][x] }
            queue.append((ny, nx))
        }
    }
    return 0 // ë¬´ì¡°ê±´ ëª©í‘œì§€ì ì— ë„ë‹¬í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ì´ ì½”ë“œëŠ” ì‹¤í–‰ë˜ì§€ ì•ŠëŠ”ë‹¤.
}
```



## 11403 ê²½ë¡œ ì°¾ê¸°

ë¬¸ì œë¡œ ì´ë™

#### ë¬¸ì œ ìš”ì•½

ê°€ì¤‘ì¹˜ ì—†ëŠ” ê·¸ë˜í”„ Gì—ì„œ, ë…¸ë“œ iì—ì„œ jë¡œ ê°€ëŠ” ê²½ë¡œê°€ ìˆëŠ”ì§€, ì—†ëŠ”ì§€ ì¸ì ‘ í–‰ë ¬ë¡œ í‘œí˜„í•´ì•¼í•˜ëŠ” ë¬¸ì œì´ë‹¤.

#### ì•Œê³ ë¦¬ì¦˜

1. ì¸ì ‘í–‰ë ¬ì„ ì…ë ¥ë°›ì•„ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ ë§Œë“ ë‹¤.
2. BFSë¥¼ ì´ìš©í•˜ì—¬ íƒìƒ‰í•˜ê³ , ì¸ì ‘ í–‰ë ¬ í˜•íƒœë¡œ í‘œí˜„í•˜ì—¬ ì¶œë ¥í•œë‹¤.

#### ì ‘ê·¼ë°©ë²•

* ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ë©´ ë‹¨ë°©í–¥ ê°„ì„ ì„ í‘œí˜„í•˜ê¸° ë” ì¢‹ë‹¤
* ì¸ì ‘ë¦¬ìŠ¤íŠ¸ë¡œ ê·¸ë˜í”„ë¥¼ ë§Œë“¤ì–´ì„œ ë°©í–¥ì´ ìˆëŠ” ê·¸ë˜í”„ë¥¼ í‘œí˜„í•˜ê³ , BFSë¡œ ì–´ë””ë¥¼ ë°©ë¬¸í•  ìˆ˜ ìˆëŠ”ì§€ ê³„ì‚°í•´ë³´ì•„ì•¼í•œë‹¤.
* ì´ë•Œ, ê¸°ì¡´ BFSì²˜ëŸ¼ ìê¸° ìì‹ ì„ ë°©ë¬¸ì²˜ë¦¬í•˜ë©´ ì•ˆ ëœë‹¤. (ë‚´ ìì‹ ì„ ë°©ë¬¸í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ë³´ì¥í•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì´ë‹¤.)
* Dictionary ì´ˆê¸°í™” ê¿€íŒ!
  * ë”•ì…”ë„ˆë¦¬ì˜ valueê°€ ë¦¬ìŠ¤íŠ¸ì¼ ë•Œ, ë§Œì•½ keyê°€ ì²˜ìŒ ë‚˜ì˜¤ëŠ” ê²½ìš°ëŠ” ëŒ€ì…ì—°ì‚°ìë¥¼ ì‚¬ìš©í•´ì•„í•˜ê³ , ì´ë¯¸ keyê°€ ì¡´ì¬í•˜ë©´ valueì— append ì—°ì‚°ì„ ìˆ˜í–‰í•´ì•¼í•œë‹¤.
  * ì´ë•Œ ì´ˆê¹ƒê°’ìœ¼ë¡œ ë”•ì…”ë„ˆë¦¬ key ê°’ì— ë¹ˆ ë°°ì—´ë¡œ ëª¨ë‘ ì´ˆê¸°í™”í•´ì£¼ë©´ ìœ„ ì—°ì‚° ì—†ì´ í•­ìƒ appendë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆë‹¤!

#### ì½”ë“œ

<pre class="language-swift"><code class="lang-swift"><strong>let n = Int(readLine()!)!
</strong>var map = [[Int]]()
var tree = [Int : [Int]]()
Array(0..&#x3C;n).forEach { tree[$0] = [] } // dictionary ì´ˆê¸°í™”

// ì¸ì ‘í–‰ë ¬ì„ ë°›ì•„ ì¸ì ‘ë¦¬ìŠ¤íŠ¸ treeì— ì €ì¥í•œë‹¤.
for y in 0 ..&#x3C; n {
    let input = readLine()!.split { $0 == " " }.map { Int($0)! }
    for x in 0 ..&#x3C; n {
        if input[x] == 1 {
            tree[y]!.append(Int(x))
        }
    }
}

// ëª¨ë“  ë…¸ë“œì— ëŒ€í•´ BFS ì—°ì‚°ì„ ìˆ˜í–‰í•œë‹¤.
Array(0..&#x3C;n).forEach {
    map.append(bfs($0))
}

// ì¶œë ¥ í˜•íƒœì— ë§ì¶° ì¶œë ¥í•œë‹¤.
map.forEach {
    $0.forEach { print($0, terminator: " " )}
    print()
}


func bfs(_ node: Int) -> [Int] {
    var result = [Int](repeating: 0, count: n) // ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ í‘œí˜„í•  ë°°ì—´, visitedì™€ ê°™ì€ ì—­í• ì„ í•œë‹¤. 
//    result[node] = 1 -> ìê¸° ìì‹ ì„ ë°©ë¬¸ì²˜ë¦¬ í•˜ì§€ ì•ŠëŠ”ë‹¤.
    
    var queue = [node]
    
    while !queue.isEmpty {
        let n = queue.removeFirst()
        
        guard let tree = tree[n] else { continue } // ë”•ì…”ë„ˆë¦¬[n] ì´ ìì‹ì„ ê°€ì§€ê³  ìˆëŠ”ê°€?
        for i in tree {
            guard result[i] == 0 else { continue } // ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´
            result[i] = 1 // ì¸ì ‘ë¦¬ìŠ¤íŠ¸ì— 1ë¡œ í‘œí˜„í•œë‹¤.
            queue.append(i)
        }
    }
    return result // ì¸ì ‘ë¦¬ìŠ¤íŠ¸ í•œ í–‰ì„ ë¦¬í„´í•œë‹¤.
}
</code></pre>
